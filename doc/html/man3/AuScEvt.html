<!-- manual page source format generated by PolyglotMan v3.0.7, -->
<!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z -->

<HTML>
<HEAD>
<TITLE>man page(1)</TITLE>
</HEAD>
<BODY bgcolor=white>
<A HREF="#toc">Table of Contents</A><P>

<H2><A NAME="sect0" HREF="#toc0">Name</A></H2>

<P>
<B>AuScanEvents</B> - return the first event that satisfies the
predicate

<H2><A NAME="sect1" HREF="#toc1"><B>Synopsis</B></A></H2>

<P>
#include &lt;audio/audiolib.h&gt;
<P>
<B>AuBool</B> <B>AuScanEvents</B>(<I>server</I>, <I>mode</I>, <I>dequeue</I>, <I>predicate</I>, <I>arg</I>,
<I>event</I>)<BR>

<B>AuServer</B> *<I>server</I>;<BR>

int <I>mode</I>;<BR>

<B>AuBool</B> <I>dequeue</I>;<BR>

<B>AuBool</B> (*<I>predicate</I>)(<B>AuServer</B> *,<B>AuEvent</B> *, <B>AuPointer</B>);
<B>AuPointer</B> <I>arg</I>;<BR>

<B>AuEvent</B> *<I>event</I>; /* <B>RETURN</B> */

<H2><A NAME="sect2" HREF="#toc2"><B>Arguments</B></A></H2>


<DL>

<DT><I>server</I> </DT></DT>
<DD>   Specifies the connection to the audio server.
</DD>

<DT><I>mode</I> </DT></DT>
<DD>     Specifies how far to look for a match. This
should    be    one    of    these    constants:
<B>AuEventsQueuedAlready</B>, <B>AuEventsQueuedAfterReading</B>,
or <B>AuEventsQueuedAfterFlush</B>.
</DD>
</DL>
<P>
<I>dequeue</I> Specifies if a matching event is found, should
it be removed from the queue.
<P>
<I>predicate</I> Specifies the procedure that is called to determine
if an event matches the criteria.

<DL>

<DT><I>arg</I> </DT></DT>
<DD>      Specifies any additional arguments to be passed
to the predicate procedure.
</DD>

<DT><I>event</I> </DT></DT>
<DD>    Returns the matching event if found.
</DD>
</DL>

<H2><A NAME="sect3" HREF="#toc3"><B>Description</B></A></H2>

<P>
<B>AuScanEvents</B> scans the event queue looking for the first
event that satisfies the caller-supplied predicate. If
<I>mode</I> is <B>AuEventsQueuedAlready</B>, <B>AuScanEvents</B> only checks
for events already in the queue.    If <I>mode</I> is
<B>AuEventsQueuedAfterReading</B>, and a matching event isn't
found already in the queue, <B>AuScanEvents</B> attempts to read
more events out of the application's connection. If <I>mode</I>
is <B>AuEventsQueuedAfterFlush</B> and a matching event isn't
already in the queue or isn't waiting to be read, <B>AuScanEvents</B>
flushes the output queue and attempts to read more
events out of the application's connection. If <I>dequeue</I> is
<B>AuTrue</B>, and a matching event is found, it is removed from
the queue. The predicate procedure is called with the
arguments <I>server</I>, <I>event</I>, and <I>arg</I> and should return <B>AuTrue</B>
to indicate a match.

<H2><A NAME="sect4" HREF="#toc4"><B>See</B> <B>Also</B></A></H2>

<P>
<B>AuEventsQueued</B>, <B>AuScanForTypedEvent</B>, <B>AuNextEvent</B>.
audiolib - <B>Network</B> <B>Audio</B> <B>System</B> C Language Interface
<P>

<HR><P>
<A NAME="toc"><B>Table of Contents</B></A><P>
<UL>
<LI><A NAME="toc0" HREF="#sect0">Name</A></LI>
<LI><A NAME="toc1" HREF="#sect1">Synopsis</A></LI>
<LI><A NAME="toc2" HREF="#sect2">Arguments</A></LI>
<LI><A NAME="toc3" HREF="#sect3">Description</A></LI>
<LI><A NAME="toc4" HREF="#sect4">See Also</A></LI>
</UL>
</BODY></HTML>
